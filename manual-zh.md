## 项目：通过抽象解释进行静态分析，适用于一种简单的数值语言

Antoine Miné

2018年9月11日

> 机翻自 https://www-apr.lip6.fr/~mine/enseignement/mpri/2018-2019/project/sujet_ok.pdf
>
> 项目现在可以通过 `dune` 构建，部分有修改，主要集中在项目结构相关的地方
>
> 假定读者已经安装好了 `opam` 和 OCaml 编译器，项目仅在 OCaml 5.2.1 上测试过，其他版本未知
>
> Setsuna 2025.2.10



### 1 介绍

本项目的目标是熟悉使用 OCaml 语言设计和编程基于抽象解释的静态分析器。为此，我们将扩展一个小型分析器，该分析器允许对一种非常简单的命令式玩具语言进行数值分析。该语法灵感来自 C，但经过了极大的简化。该语言仅包含整数（在 $\mathbb{Z}$ 中）作为数据类型，以及 `if then else` 和 `while` 循环作为控制结构。该语言不包含指针、函数、数组、动态分配或对象。

本项目假定您事先了解抽象解释和 OCaml 编程。关于抽象解释部分，可以参考以下两个课程：

+ 巴黎 7 大 MPRI 的 M2-6 课程（英文）；

+ 索邦大学 Master STL 的 TAS 课程（法文）。

本项目灵感来自在 École normale supérieure 以及索邦大学 Master STL 中给出的一个项目。

#### 1.1 基本代码

您将在项目档案中找到一个基本框架，以方便分析的开发：

+ 一个语法分析器，将程序的文本转换为抽象语法树；

+ 一个基于语法归纳的解释器，由解释域的选择参数化；

+ 环境域和值域的签名；

+ 具体域，允许收集程序可访问的精确状态集合；

+ 常量抽象域。

解释器和常量域还不完整。因此，第一项任务是完善它们。

#### 1.2 依赖项

必须安装以下依赖项才能编译项目：

+ OCaml 语言；

+ Menhir：OCaml 的语法分析器生成器；

+ GMP：一个多精度整数的 C 库（Zarith 和 Apron 需要）；

+ MPFR：一个多精度浮点数的 C 库（Apron 需要）；

+ Zarith：一个 OCaml 多精度整数库；

+ CamlIDL：一个 OCaml C 接口库；

+ Apron：一个 C/OCaml 数值域库。

在 Ubuntu（和衍生发行版）下，可以使用 `apt-get` 和 `opam` 安装依赖项：

```shell
# 假定你已经安装好了 opam 和至少一个有效的 switch
sudo apt-get update
sudo apt-get install -y m4 libgmp3-dev libmpfr-dev
opam install -y menhir zarith mlgmpidl apron
```

#### 1.3 编译和测试

安装依赖项后，执行 `dune bulid` 进行编译。生成的执行文件是 `_build/install/default/bin/analyzer`。如果编译成功，您可以在项目根目录测试二进制文件：

+ `dune exec analyzer --root=. -- tests/0011_rand.c` 应该在控制台上显示程序 `tests/01_concrete/0111_rand.c` 的文本（实际上，程序已被解析器转换为 AST 并转换回文本）；

+ `dune exec analyzer --root=. -- tests/0011_rand.c -concrete` 应该在控制台上显示测试程序所有可能执行的结果，这里是 `x` 的值介于 $1$ 和 $5$ 之间。

### 2 项目架构

源代码的目录结构如下：

+ `Makefile`：分析器的编译文件，随着您添加源文件而修改；

+ `src/main.ml`：入口点，分析命令行选项，启动语法和语义分析；用于连接新的分析并添加选项；

+ `libs/`：库文件
  + `libs/mapext`：包含 OCaml `Map` 模块的略微改进版本；

  + `libs/frontend/`：将源（文本）转换为抽象语法树：
    + `libs/frontend/abstract_syntax_tree.ml`：语法树的类型；

    + `libs/frontend/lexer.mll`：`OCamlLex` 词法分析器；

    + `libs/frontend/parser.mly`：`Menhir` 语法分析器；

    + `libs/frontend/file_parser.ml`：将源转换为语法树的入口点；

    + `libs/frontend/abstract_syntax_printer.ml`：反向转换，以源的形式显示语法树；

  + `libs/domains/`：语义的解释域；
    + `libs/domains/domain.ml`：表示环境集合的域的签名；

    + `libs/domains/concrete_domain.ml`：具体域，环境表示为表的集合，将每个变量与其值相关联；

    + `libs/domains/value_domain.ml`：表示整数集合的域的签名；

    + `libs/domains/constant_domain.ml`：整数集合域的一个示例（因此符合 `Value_domain.VALUE_DOMAIN` 签名）：常量域；

    + `libs/domains/non_relational_domain.ml`：一个函子，给定一个表示整数集合的域 (`Value_domain.VALUE_DOMAIN`)，构建一个表示环境集合的域 (`Domain.DOMAIN`)，通过将每个变量与一个抽象整数集合相关联；

  + `libs/interpreter/interpreter.ml`：程序的通用解释器，由环境域 (`Domain.DOMAIN`) 参数化；

+ `tests/`：一组用分析语言编写的程序，用于测试您的分析器。

+ `tests/tests-constant/, tests/result-interval/`：分析结果，使用参考分析器获得（未提供！），可以用作与您的分析器比较的参考点。

### 3 语言语法

玩具语言遵循在语法文件 `parser.mly` 中描述的语法。我们简要地描述它，知道 `tests/` 目录中的示例也允许您熟悉语法。此外，文件 `abstract_syntax_tree.ml` 给出了语言构造的精确概念。

程序是一系列指令：

+ tests：`if (bexpr) { block } 或 if (bexpr) { block } else { block }`;

+ loops：`while (bexpr) { block }`;

+ assignments：`var = expr`;

+ blocks：`{ decl1; ...; decln; inst1; ...; instn }` 由一系列变量声明 `int var` 和一系列指令组成；仅识别 `int` 类型；声明没有初始化（必须后跟赋值）；一次只能声明一个变量（`int a,b;` 不起作用，必须写 `int a; int b;`）；所有声明必须在块中所有指令之前；没有全局变量，所有变量都必须在块中声明；

+ 整数表达式，用于赋值，由经典运算符 `+, -, *, /`、变量、常量以及一个特殊操作 `rand(l,h)` 组成，其中 `l` 和 `h` 是两个整数，表示 `l` 和 `h` 之间的整数集合；

+ 布尔表达式，用于测试和循环，由运算符 `&&, ||, !`、常量 `true` 和 `false` 以及借助运算符 `<, <=, >, >=, ==, !=` 比较两个整数表达式组成；

+ `print(var1,...,varn)` 允许显示变量 `var1` 到 `varn` 的值；

+ `halt` 停止程序；

+ `assert(bexpr)` 如果布尔条件未验证，则停止程序并显示错误消息，否则继续正常执行。

一个简单的有效程序示例是：

```c
{
    int x;
    x = 2+2;
    print(x);
}
```

有关语法的更多信息，您可以查阅语法分析文件 `libs/frontend/parser.mly`。您还可以在 `tests` 目录中找到程序示例。

### 4 需要完成的工作

#### 4.1 上手操作，具体域

选项 `-concrete` 允许在具体收集语义中执行程序。

您还可以使用选项 `-trace` 来观察计算的执行过程（在每条指令后显示环境）。

##### 4.1.1 观察

在提供的示例上启动具体分析，并创建您的测试示例。目的是回答以下关于程序语义及其与具体解释器行为之间关系的问题，并通过测试验证您的答案：

+ 指令 `rand(l,h)` 在程序中的语义是什么？解释器的预期结果是什么？

+ 程序的执行在什么条件下停止？那么解释器的结果是什么？

+ 如果程序包含无限循环，解释器是否仍然可以终止？在什么情况下？

##### 4.1.2 断言

您可能在测试中注意到，`assert` 指令的行为类似于 `skip` 指令：它什么也不做。在本问题中，您将修改 `interpreter.ml` 以更正其解释，即：

+ 如果断言未被证明是正确的，则显示错误消息；

+ 并在假设它正确的情况下继续分析（这样做是为了不向用户指示多个具有相同原因的错误）。

##### 4.1.3 丰富

实现以下扩展：

+ 向语言添加一个模运算 `%`（需要稍微修改词法分析、语法分析、语法树和解释域；提示：从现有的操作（如乘法）开始，以遵循要进行的修改）；

+ 程序的 `int` 类型对应于完美的数学整数；在 `concrete_domain.ml` 中修改此解释以对应于 32 位有符号整数，并用程序示例说明行为的不同之处（提示：可以将 32 位运算视为对数学整数的运算，然后进行校正运算，将结果带回 $[-2^{31}, 2^{31} - 1]$；因此，只需在每次计算后添加此步骤）。

#### 4.2 常量域

可以使用选项 `-constant` 访问常量分析。但是，该域不完整。本练习的目的是完成它。您将特别关注以下测试的结果：

+ `0024_mul_rand.c`

+ `0100_if_true.c`

+ `0101_if_false.c`

+ `0209_cmp_eq_ne.c`

在每种情况下，确定 `constant_domain.ml` 中不精确的来源并进行纠正。

此外，除法的处理并不像它可能的那样精确。确定并纠正这种不精确性。提出强调您的更正的测试。

#### 4.3 区间域

在本练习中，您将实现区间域。与常量域一样，它符合签名 `Value_domain.VALUE_DOMAIN`，并用作函子 `Non_relational_domain.NonRelational` 的参数。注意，我们管理任意数学整数。因此，区间的界限不一定是整数，也可以是 $+∞$ 或 $-∞$。

签名 `Value_domain.VALUE_DOMAIN` 包含许多函数。您将以最精确的方式实现至少以下函数：`top, bottom, const, rand, meet, join, subset, is_bottom, print, unary, binary, compare`。对于函数 `bwd_unary` 和 `bwd_binary`，近似实现就足够了。但是，至关重要的是，即使结果不精确，所有函数都应返回安全的结果。

#### 4.4 循环分析

`interpreter.ml` 中循环的处理假设抽象域没有严格递增的无限链。那么在区间分析期间会发生什么？

本问题的目的是通过添加扩大 (`widening`) 的使用来纠正此问题。我们将逐步进行：

确保扩大操作已在区间域中正确实现；

修改 `interpreter.ml` 以便在每个循环中使用扩大操作；

添加一个选项 `-delay n`，允许用并集 (延迟扩大) 替换前 `n` 个扩大操作的应用；

添加一个选项 `-unroll n`，允许在用扩大进行计算之前展开前 `n` 个循环；与 `-delay n` 有什么区别？（用例子说明）；

添加递减迭代以细化结果（也用例子说明精度增益）。

#### 4.5 约简积

实现奇偶校验域，允许推断每个变量是偶数还是奇数。

然后实现区间与奇偶校验的约简积。提出程序示例，展示这种约简的意义。尽可能尝试定义一个通用的“约简积”函子，该函子以任意值抽象域作为参数。

### 5 扩展

本节介绍您可以对分析器进行的多项改进。

#### 5.1 机器整数分析

作为问题 4.1.3 的补充，修改所有实现的域（常量、区间、奇偶校验），以便语义对应于 32 位有符号整数中的计算，而不是数学整数中的计算。在示例中显示这两种语义之间的差异，尤其是在分析精度方面的影响。

#### 5.2 分离分析

区间分析不精确，因为它仅表示凸值集。几种构造允许通过推理区间的析取来纠正此问题：析取完成、状态分区、轨迹分区。在您的分析器中实现其中一项技术，并提供示例来说明它带来的精度改进。

#### 5.3 关系分析

添加对关系数值域的支持。您可以依靠 Apron 库，该库提供了八边形和多面体的所有已完成实现，并具有 OCaml 接口。提供示例来说明精度的提高。

#### 5.4 数组分析

在您的语言和分析中添加对数组的支持。每个数组都将以固定大小声明，例如：`int tab[10]`。在数组 `tab[expr]` 中访问期间，我们感兴趣的是：

验证表达式 `expr` 是否代表数组的有效索引，即是否求值为 `0` 到 `n - 1` 之间的值（否则，将显示错误，类似于断言失败）；

推断有关数组中包含的值的信息（例如，值的范围）。

对于第二点，可以使用两种数组的抽象表示：

+ 将每个单元格 `tab[0], ..., tab[n-1]` 视为一个独立变量，并将一个区间与其关联；

+ 或使用单个变量 `tab[*]` 和每个数组的唯一区间，该区间表示数组所有单元格的所有可能值的集合。

您将实现这两种技术，并提供示例来说明精度和成本之间的差异。

#### 5.5 指针分析

在您的语言和分析中添加对指针的支持。

指针变量将使用 `ptr p` 声明。如果 `x` 是一个整数变量，那么可以通过指令 `p = &x` 将对 `x` 的引用存储在 `p` 中。可以通过 `*p` 读取 `p` 引用的变量，可以在任何表达式中使用（例如，我们可以写 `x = *p + 1`）。可以通过 `*p = expression` 修改 `p` 引用的变量。最后，如果 `q` 也是一个引用，则可以通过 `p = q` 将其复制到 `p` 中（因此，`*p` 和 `*q` 表示相同的变量）。

读取或修改未初始化指针（在 `ptr p` 和第一次赋值 `p = ...` 之间）引用的值会导致错误。此外，如果 `p` 引用在块中声明的变量 `x`，则在该块退出后引用此指针也会导致错误。分析器应检测到这些错误并显示它们。

可以通过一个指针域将指针支持添加到分析器，该域将每个指针变量与一组可能的引用变量相关联。您将实现此技术并提供示例来说明它。

#### 5.6 字符串分析

在您的语言和分析中添加对字符串的支持。

字符串变量将通过 `string s` 声明。我们假设字符串是不可变的（如在 Java 中，与 C 不同）。为了将我们的表达式扩展到字符串，我们添加以下语法：

+ 字符串文字常量，用引号引起来，例如：`"toto"`；

+ 连接运算符 `.` (点)：`s = "un " . "mot"`；

+ 提取字符串的长度：`i = length(s)`。

可以通过以下域之一将字符串支持添加到分析器（按复杂性递增的顺序排列）：

+ 一个域，保留可能出现在字符串中的字母集合，而不记住它们的出现次数或它们的位置；

+ 一个域，将每个字符串与其大小相关联，然后可以在数值域（如区间）甚至关系数值域中抽象此信息（以发现字符串大小和数值变量之间的关系）；

+ 一个通过有限自动机近似所有可能字符串集合的域；

+ 两个（或更多）域的约简积。